---
title: Inline Mode
description: Render TUI components inline without taking over the terminal
---

Inline mode lets you render components directly into the terminal's scrollback history instead of using the alternate screen buffer. This is ideal for CLIs, test runners, build tools, and interactive prompts where you want output to remain visible after the app exits.

## Basic Usage

```dart
import 'package:nocterm/nocterm.dart';

void main() async {
  await runApp(
    MyProgressIndicator(),
    screenMode: ScreenMode.inline,
  );
}
```

By default, Nocterm uses `ScreenMode.alternateScreen`, which takes over the full terminal and restores the previous content on exit. With `ScreenMode.inline`, your component renders in place and the output stays in the terminal history.

## Screen Modes

| Mode | Behavior |
|------|----------|
| `alternateScreen` | Full-screen TUI, content cleared on exit (default) |
| `inline` | Renders in place, content stays in terminal history |

## Exit Behaviors

When using inline mode, you can control what happens when the app exits:

```dart
await runApp(
  MyComponent(),
  screenMode: ScreenMode.inline,
  inlineExitBehavior: InlineExitBehavior.preserve, // default
);
```

| Behavior | Description |
|----------|-------------|
| `preserve` | Leave output visible after exit (default) |
| `clear` | Erase all rendered content on exit |

## How It Works

### Layout

In inline mode, components are laid out with unbounded height constraints. This means your component determines its own natural height rather than filling the terminal.

```dart
// In alternate screen mode:
// constraints = BoxConstraints.tight(terminalSize)

// In inline mode:
// constraints = BoxConstraints(
//   maxWidth: terminalWidth,
//   maxHeight: double.infinity,  // unbounded!
// )
```

### Scrollback Handling

When your component's height exceeds the terminal height, the top portion scrolls into the terminal's scrollback buffer. This has an important implication:

**Content in scrollback is frozen** - you can't update it anymore.

```
┌─────────────────────────────┐
│  Scrollback buffer          │  ← Frozen, can't update
│  (terminal history)         │
├─────────────────────────────┤
│  Visible viewport           │  ← Your component renders here
│  (updatable region)         │
└─────────────────────────────┘
```

## Best Practices

### Put Dynamic Content at the Bottom

Since top content may scroll into the frozen scrollback buffer, design your layouts with static content at the top and dynamic/updating content at the bottom:

```
Good pattern:
┌─────────────────────────────┐
│ Header (static)             │  ← May scroll into scrollback
│ Completed items...          │     (that's OK - it's static)
├─────────────────────────────┤
│ Currently running item      │  ← Stays visible, updates
│ Progress bar / Summary      │
└─────────────────────────────┘
```

```
Avoid this pattern:
┌─────────────────────────────┐
│ Dynamic content that        │  ← If this scrolls up,
│ changes frequently          │     you can't update it!
├─────────────────────────────┤
│ Static footer               │
└─────────────────────────────┘
```

### Example: Test Runner Layout

A test runner is a perfect use case for inline mode:

```dart
class TestRunner extends StatefulComponent {
  @override
  Component build(BuildContext context) {
    return Column(
      children: [
        // Static: completed tests (OK to scroll into history)
        for (final test in completedTests)
          Text('✓ ${test.name}', style: TextStyle(color: Colors.green)),

        // Dynamic: current test (stays at bottom, always visible)
        if (currentTest != null)
          Text('⋯ ${currentTest.name}...', style: TextStyle(color: Colors.yellow)),

        // Dynamic: summary line (always visible)
        Divider(),
        Text('${passed} passed, ${failed} failed | ${elapsed}s'),
      ],
    );
  }
}
```

## Use Cases

Inline mode is perfect for:

- **Test runners** - Show test results scrolling up, current test at bottom
- **Build tools** - Progress and status at bottom, logs scrolling up
- **Interactive prompts** - Question/answer flows
- **Project scaffolders** - Step-by-step progress indicators
- **Log viewers** - Stream output with live status

## Examples

See the example apps in the repository:

- `example/inline_demo.dart` - Simple progress bar
- `example/test_runner_demo.dart` - Simulated test runner with 40 tests

Run them with:

```bash
dart run example/inline_demo.dart
dart run example/test_runner_demo.dart
```

## Limitations

1. **No scrollback updates** - Once content scrolls into the scrollback buffer, it's frozen
2. **Web platform** - Inline mode is not supported on web; it will fall back to alternate screen
3. **Mouse tracking** - Still enabled in inline mode, which may affect some terminals
